'use strict';

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
    value: true
});
exports.option = option;
exports.section = section;
exports.map = map;
exports.root = root;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _lazy = require('./lazy');

var _errors = require('./errors');

var _locator = require('./locator');

var _locator2 = _interopRequireDefault(_locator);

/**
 * Single option
 */

function option(_ref) {
    var defaultValue = _ref.defaultValue;
    var _ref$parseCli = _ref.parseCli;
    var parseCli = _ref$parseCli === undefined ? _lodash2['default'].identity : _ref$parseCli;
    var _ref$parseEnv = _ref.parseEnv;
    var parseEnv = _ref$parseEnv === undefined ? _lodash2['default'].identity : _ref$parseEnv;
    var _ref$validate = _ref.validate;
    var validate = _ref$validate === undefined ? _lodash2['default'].noop : _ref$validate;
    var _ref$map = _ref.map;
    var mapFunc = _ref$map === undefined ? _lodash2['default'].identity : _ref$map;

    return function (locator, parsed) {
        var config = parsed.root;
        var currNode = locator.parent ? _lodash2['default'].get(config, locator.parent) : config;

        var value = undefined;
        if (locator.cliOption !== undefined) {
            value = parseCli(locator.cliOption);
        } else if (locator.envVar !== undefined) {
            value = parseEnv(locator.envVar);
        } else if (locator.option !== undefined) {
            value = locator.option;
        } else if (defaultValue !== undefined) {
            value = _lodash2['default'].isFunction(defaultValue) ? defaultValue(config, currNode) : defaultValue;
        } else {
            throw new _errors.MissingOptionError(locator.name);
        }
        validate(value, config, currNode);

        return mapFunc(value, config, currNode);
    };
}

/**
 * Object with fixed properties.
 * Any unknown property will be reported as error.
 */

function section(properties) {
    var expectedKeys = _lodash2['default'].keys(properties);
    return function (locator, config) {
        var unknownKeys = _lodash2['default'].difference(_lodash2['default'].keys(locator.option), expectedKeys);
        if (unknownKeys.length > 0) {
            throw new _errors.UnknownKeysError(unknownKeys.map(function (key) {
                return locator.name + '.' + key;
            }));
        }

        var lazyResult = (0, _lazy.buildLazyObject)(expectedKeys, function (key) {
            var parser = properties[key];
            return function () {
                return parser(locator.nested(key), config);
            };
        });

        _lodash2['default'].set(config, locator.name, lazyResult);

        return lazyResult;
    };
}

/**
 * Object with user-specified keys and values,
 * parsed by valueParser.
 */

function map(valueParser, defaultValue) {
    return function (locator, config) {
        if (locator.option === undefined) {
            if (!defaultValue) {
                return {};
            }
            locator = locator.resetOption(defaultValue);
        }

        var optionsToParse = _Object$keys(locator.option);
        var lazyResult = (0, _lazy.buildLazyObject)(optionsToParse, function (key) {
            return function () {
                return valueParser(locator.nested(key), config);
            };
        });
        _lodash2['default'].set(config, locator.name, lazyResult);

        return lazyResult;
    };
}

function root(rootParser, _ref2) {
    var envPrefix = _ref2.envPrefix;

    return function (_ref3) {
        var options = _ref3.options;
        var env = _ref3.env;
        var argv = _ref3.argv;

        var rootLocator = (0, _locator2['default'])({ options: options, env: env, argv: argv, envPrefix: envPrefix });
        var parsed = {};
        rootParser(rootLocator, parsed);
        return (0, _lazy.forceParsing)(parsed.root);
    };
}